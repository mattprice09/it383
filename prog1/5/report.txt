The custom shell project turned out to be a really good lesson in terms of learnng how operating systems work, how C commands function, and how the C language works in general.
My strategy was to first create a shell that could run basic commands through `exec` calls. This involved writing a quick parser that parses through the user's input and dissects it into segments. I couldn't simply use `strtok()` because many arguments for functions contain spaces within quotations. If I had called `strtok()` then the argument would have been broken up. Hence, I had to go through the input character by character. This actually turned out to be somewhat useful as, later on, I was able to add quick snippets into the parser to determine if there was any piping, redirection, or "run-in-background" specifications. 
Once the shell was fully functional, I then had to handle the running of commands in the background ("&"). This flag was determined logically when I parsed the command for the first time, thus I created the "Command" struct in order to return multiple values. In terms of command execution, if the user specified to run the command in the background then I simply didn't call `wait()` in the parent process after forking.
Piping outputs between multiple commands turned out to be the trickiest part of the program. I had to spend a good amount of time looking at lecture notes and StackOverflow in order to become extremely in-tuned to how `dup2()`, `dup()`, `pipe()`, and `fork()` worked together. I was receiving buggy output for a really long time, but then I realized that I wasn't closing all of the necessary file descriptors. Additionally, I needed to call `wait()` for each child process created instead of simply the final child process. I was wrongly assuming that my child processes from within my `spawnSubCommand()` function did not need to have `wait()` called for them.
After I finished the piping feature, I felt comfortable with handling multiple sub-processes and file descriptors. Thus, I was able to implement the output redirection feature with very little trouble.
As for the "history" feature, this was relatively straightforward. I created an array of strings that stored the user's history in the order in which they were received. When the array got full, I doubled the array's size using `realloc()`. I did consider that using a linked list might introduce less overhead when appending history, however the lookup time (O(n)) wasn't worth it in my opinion.
All in all, this was a great learning experience. Concepts such as piping and redirection are used not only at the OS level but also in web applications for streaming outputs and whatnot, thus these skills will be valuable in the future regardless of what area of CS I'm working in.